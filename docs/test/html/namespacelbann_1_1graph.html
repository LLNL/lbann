<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LBANN: lbann::graph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LBANN
   &#160;<span id="projectnumber">@LBANN_MAJOR_VERSION@.@LBANN_MINOR_VERSION@</span>
   </div>
   <div id="projectbrief">LivermoreBigArtificialNeuralNetworkToolkit</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacelbann_1_1graph.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">lbann::graph Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a956e9f6f1b842a2ffe5bda9015bbb906"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#a956e9f6f1b842a2ffe5bda9015bbb906">print</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges, std::ostream &amp;os)</td></tr>
<tr class="separator:a956e9f6f1b842a2ffe5bda9015bbb906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad305e0d104d25d9cb1e63a4b93c0847c"><td class="memItemLeft" align="right" valign="top">std::set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a> (int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:ad305e0d104d25d9cb1e63a4b93c0847c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c1819b38f8bc514ab24ac8778f840b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">is_closure</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:ac9c1819b38f8bc514ab24ac8778f840b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd9dcef8bc13481677692347530e328"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328">is_topologically_sorted</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a0dd9dcef8bc13481677692347530e328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb66f3455c79ca9c959bcf2c36a92eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb">is_cyclic</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a7cb66f3455c79ca9c959bcf2c36a92eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b0b97c3fc0b88f2fffd44f1b951c71"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::set&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#a53b0b97c3fc0b88f2fffd44f1b951c71">transpose</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a53b0b97c3fc0b88f2fffd44f1b951c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54de9f8e26046c834acfc5436a93b66b"><td class="memItemLeft" align="right" valign="top">std::map&lt; int, std::set&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#a54de9f8e26046c834acfc5436a93b66b">induce_subgraph</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a54de9f8e26046c834acfc5436a93b66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc9ff6e6b9707deaa1c77c3b8eb0b20"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#a6cc9ff6e6b9707deaa1c77c3b8eb0b20">breadth_first_search</a> (int root, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a6cc9ff6e6b9707deaa1c77c3b8eb0b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44394207f3566604f867382b10aaf974"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974">depth_first_search</a> (int root, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:a44394207f3566604f867382b10aaf974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb19a22d8fac402df104ed8d547a10ee"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee">topological_sort</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</td></tr>
<tr class="separator:aeb19a22d8fac402df104ed8d547a10ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06c3de1931d3786348995d870b792ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca">condensation</a> (const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges, std::map&lt; int, std::set&lt; int &gt;&gt; &amp;components, std::set&lt; int &gt; &amp;condensation_nodes, std::map&lt; int, std::set&lt; int &gt;&gt; &amp;condensation_edges)</td></tr>
<tr class="separator:ae06c3de1931d3786348995d870b792ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6cc9ff6e6b9707deaa1c77c3b8eb0b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc9ff6e6b9707deaa1c77c3b8eb0b20">&#9670;&nbsp;</a></span>breadth_first_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; lbann::graph::breadth_first_search </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a breadth-first search starting from a given root node. The search order is deterministic. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00158">158</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;                                                                            {</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;  <span class="comment">// Initialize data structures</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;  std::unordered_map&lt;int,bool&gt; is_visited;</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  std::vector&lt;int&gt; sorted_nodes;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  std::queue&lt;int&gt; search_queue;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  search_queue.push(root);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;  <span class="comment">// Visit nodes until search queue is exhausted</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;  <span class="keywordflow">while</span> (!search_queue.empty()) {</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node = search_queue.front();</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    search_queue.pop();</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      <span class="keywordflow">if</span> (!is_visited[neighbor]) {</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        is_visited[neighbor] = <span class="keyword">true</span>;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        sorted_nodes.push_back(neighbor);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;        search_queue.push(neighbor);</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      }</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    }</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  }</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;  <span class="comment">// Return list of sorted nodes</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  <span class="keywordflow">return</span> sorted_nodes;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20_cgraph" id="namespacelbann_1_1graph_a6cc9ff6e6b9707deaa1c77c3b8eb0b20_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="201,12,389,37"/>
</map>
</div>

</div>
</div>
<a id="ae06c3de1931d3786348995d870b792ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06c3de1931d3786348995d870b792ca">&#9670;&nbsp;</a></span>condensation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lbann::graph::condensation </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>condensation_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>condensation_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the condensation of a graph. The condensation of a graph is constructed by determining the strongly connected components, i.e. sets of nodes that are reachable from all nodes in the set, and coalescing them into single nodes. The condensation is a DAG and will be topologically sorted. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00267">267</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                                                               {</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="comment">// Initialize data structures for unsorted condensation</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  std::unordered_map&lt;int,std::set&lt;int&gt;&gt; unsorted_components;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  std::unordered_map&lt;int,int&gt; unsorted_component_assignments;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;  std::set&lt;int&gt; unsorted_condensation_nodes;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  std::map&lt;int,std::set&lt;int&gt;&gt; unsorted_condensation_edges;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;  <span class="comment">// Find strongly connected components with Kosaraju&#39;s algorithm</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;  <span class="comment">// Note: First sort nodes by DFS post-order. Then, pick root nodes</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="comment">// in DFS post-order and perform DFS on graph transpose. The first</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="comment">// DFS that visits a node determines the strongly connected</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;  <span class="comment">// component it belongs to.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; transpose_edges = <a class="code" href="namespacelbann_1_1graph.html#a53b0b97c3fc0b88f2fffd44f1b951c71">transpose</a>(nodes, edges);</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  std::stack&lt;int&gt; dfs_stack;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  std::unordered_map&lt;int,bool&gt; is_sorted, is_condensed;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; root : nodes) {</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;    <span class="keywordflow">if</span> (!is_sorted[root]) {</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : <a class="code" href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974">depth_first_search</a>(root, edges)) {</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordflow">if</span> (!is_sorted[node]) {</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;          is_sorted[node] = <span class="keyword">true</span>;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;          dfs_stack.push(node);</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        }</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;      }</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    }</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  }</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;  <span class="keywordflow">while</span> (!dfs_stack.empty()) {</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; root = dfs_stack.top();</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;    dfs_stack.pop();</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    <span class="keywordflow">if</span> (!is_condensed[root]) {</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;      <span class="keyword">const</span> <span class="keywordtype">int</span> index = unsorted_condensation_nodes.size();</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;      unsorted_condensation_nodes.insert(index);</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : <a class="code" href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974">depth_first_search</a>(root, transpose_edges)) {</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keywordflow">if</span> (!is_condensed[node]) {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;          is_condensed[node] = <span class="keyword">true</span>;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;          unsorted_component_assignments[node] = index;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;          unsorted_components[index].insert(node);</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;      }</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;    }</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  }</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="comment">// Find edges in unsorted condensation</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : nodes) {</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; unsorted_component = unsorted_component_assignments[node];</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor_unsorted_component = unsorted_component_assignments[neighbor];</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;      <span class="keywordflow">if</span> (unsorted_component != neighbor_unsorted_component) {</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        unsorted_condensation_edges[unsorted_component].insert(neighbor_unsorted_component);</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;      }</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;    }</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  }</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  <span class="comment">// Topologically sort condensation</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; sorted_to_unsorted = <a class="code" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee">topological_sort</a>(unsorted_condensation_nodes,</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                                                    unsorted_condensation_edges);</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="comment">// Record sorted condensation to output</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  components.clear();</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  condensation_nodes.clear();</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  condensation_edges.clear();</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; unsorted_condensation_nodes.size(); ++i) {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;    condensation_nodes.insert(i);</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  }</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  std::unordered_map&lt;int,int&gt; unsorted_to_sorted;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; component : condensation_nodes) {</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; unsorted_component = sorted_to_unsorted[component];</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    unsorted_to_sorted[unsorted_component] = component;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  }</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; unsorted_component : unsorted_condensation_nodes) {</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; component = unsorted_to_sorted[unsorted_component];</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    components[component] = unsorted_components[unsorted_component];</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor_unsorted_component : unsorted_condensation_edges[unsorted_component]) {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      condensation_edges[component].insert(unsorted_to_sorted[neighbor_unsorted_component]);</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    }</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  }</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_a44394207f3566604f867382b10aaf974"><div class="ttname"><a href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974">lbann::graph::depth_first_search</a></div><div class="ttdeci">std::vector&lt; int &gt; depth_first_search(int root, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00185">graph.cpp:185</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_a53b0b97c3fc0b88f2fffd44f1b951c71"><div class="ttname"><a href="namespacelbann_1_1graph.html#a53b0b97c3fc0b88f2fffd44f1b951c71">lbann::graph::transpose</a></div><div class="ttdeci">std::map&lt; int, std::set&lt; int &gt; &gt; transpose(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00129">graph.cpp:129</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_aeb19a22d8fac402df104ed8d547a10ee"><div class="ttname"><a href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee">lbann::graph::topological_sort</a></div><div class="ttdeci">std::vector&lt; int &gt; topological_sort(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00222">graph.cpp:222</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca_cgraph" id="namespacelbann_1_1graph_ae06c3de1931d3786348995d870b792ca_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#a53b0b97c3fc0b88f2fffd44f1b951c71" title="lbann::graph::transpose" alt="" coords="696,43,858,69"/>
<area shape="rect" id="node4" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="1133,170,1320,195"/>
<area shape="rect" id="node5" href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974" title="lbann::graph::depth\l_first_search" alt="" coords="488,271,624,310"/>
<area shape="rect" id="node6" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee" title="lbann::graph::topological_sort" alt="" coords="236,170,432,195"/>
<area shape="rect" id="node3" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b" title="lbann::graph::is_closure" alt="" coords="922,145,1085,170"/>
<area shape="rect" id="node7" href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb" title="lbann::graph::is_cyclic" alt="" coords="480,170,632,195"/>
<area shape="rect" id="node8" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328" title="lbann::graph::is_topologically\l_sorted" alt="" coords="680,246,874,285"/>
</map>
</div>

</div>
</div>
<a id="a44394207f3566604f867382b10aaf974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44394207f3566604f867382b10aaf974">&#9670;&nbsp;</a></span>depth_first_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; lbann::graph::depth_first_search </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a depth-first search starting from a given root node. A depth-first search post-order is returned. The search order is deterministic. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00185">185</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;                                                                          {</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  <span class="comment">// Initialize data structures</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  std::unordered_map&lt;int,bool&gt; is_visited, is_sorted;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  std::vector&lt;int&gt; sorted_nodes;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  std::stack&lt;int&gt; search_stack;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  search_stack.push(root);</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="comment">// Visit nodes until search stack is exhausted</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="keywordflow">while</span> (!search_stack.empty()) {</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node = search_stack.top();</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    search_stack.pop();</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">if</span> (!is_sorted[node]) {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      <span class="keywordflow">if</span> (is_visited[node]) {</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;        <span class="comment">// Add node to sorted list if we have already visited</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;        is_sorted[node] = <span class="keyword">true</span>;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        sorted_nodes.push_back(node);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;        <span class="comment">// Visit node and add neighbors to search stack</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;        is_visited[node] = <span class="keyword">true</span>;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        search_stack.push(node);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;          <span class="keywordflow">if</span> (!is_visited[neighbor] &amp;&amp; !is_sorted[neighbor]) {</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            search_stack.push(neighbor);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;          }</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;        }</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      }</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    }</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  }</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="comment">// Return list of sorted nodes</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keywordflow">return</span> sorted_nodes;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_cgraph" id="namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="190,12,377,37"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_icgraph.png" border="0" usemap="#namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_icgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_icgraph" id="namespacelbann_1_1graph_a44394207f3566604f867382b10aaf974_icgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee" title="lbann::graph::topological_sort" alt="" coords="190,65,386,91"/>
<area shape="rect" id="node7" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca" title="lbann::graph::condensation" alt="" coords="434,116,616,141"/>
<area shape="rect" id="node3" href="classlbann_1_1directed__acyclic__graph__model.html#a2a70d5719832c481db9fa962f6e5f2bd" title="lbann::directed_acyclic\l_graph_model::setup_layer\l_execution_order" alt="" coords="434,40,617,92"/>
<area shape="rect" id="node4" href="classlbann_1_1directed__acyclic__graph__model.html#a9f2a6e9472235ec91c5a50356471b3cb" title="lbann::directed_acyclic\l_graph_model::freeze_layers\l_under_frozen_surface" alt="" coords="665,5,859,57"/>
<area shape="rect" id="node5" href="classlbann_1_1siamese__model.html#a7ff41cffb060500605124959f1a2a6cf" title="lbann::siamese_model\l::setup_layer_topology" alt="" coords="684,81,840,120"/>
<area shape="rect" id="node6" href="classlbann_1_1siamese__model.html#ad745961977aa395e11543d263103126e" title="lbann::siamese_model\l::name" alt="" coords="907,81,1062,120"/>
</map>
</div>

</div>
</div>
<a id="ad305e0d104d25d9cb1e63a4b93c0847c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad305e0d104d25d9cb1e63a4b93c0847c">&#9670;&nbsp;</a></span>get_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; int &gt; lbann::graph::get_neighbors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get nodes adjacent to a given node. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00049">49</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;                                                                  {</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;  <span class="keywordflow">if</span> (edges.count(node) &gt; 0) {</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">return</span> edges.at(node);</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <span class="keywordflow">return</span> std::set&lt;int&gt;();</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  }</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;}</div></div><!-- fragment --><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c_icgraph.png" border="0" usemap="#namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c_icgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c_icgraph" id="namespacelbann_1_1graph_ad305e0d104d25d9cb1e63a4b93c0847c_icgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#a956e9f6f1b842a2ffe5bda9015bbb906" title="lbann::graph::print" alt="" coords="258,5,387,31"/>
<area shape="rect" id="node3" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b" title="lbann::graph::is_closure" alt="" coords="241,208,404,233"/>
<area shape="rect" id="node4" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328" title="lbann::graph::is_topologically\l_sorted" alt="" coords="452,43,645,81"/>
<area shape="rect" id="node9" href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb" title="lbann::graph::is_cyclic" alt="" coords="700,157,852,183"/>
<area shape="rect" id="node15" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca" title="lbann::graph::condensation" alt="" coords="1151,296,1334,321"/>
<area shape="rect" id="node16" href="namespacelbann_1_1graph.html#a53b0b97c3fc0b88f2fffd44f1b951c71" title="lbann::graph::transpose" alt="" coords="468,309,629,335"/>
<area shape="rect" id="node17" href="namespacelbann_1_1graph.html#a54de9f8e26046c834acfc5436a93b66b" title="lbann::graph::induce\l_subgraph" alt="" coords="251,360,393,399"/>
<area shape="rect" id="node18" href="namespacelbann_1_1graph.html#a6cc9ff6e6b9707deaa1c77c3b8eb0b20" title="lbann::graph::breadth\l_first_search" alt="" coords="248,423,396,461"/>
<area shape="rect" id="node19" href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974" title="lbann::graph::depth\l_first_search" alt="" coords="708,259,844,297"/>
<area shape="rect" id="node10" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee" title="lbann::graph::topological_sort" alt="" coords="907,208,1103,233"/>
<area shape="rect" id="node5" href="classlbann_1_1sequential__model.html#a3801a58530388fb6a8cb3e1c018e827d" title="lbann::sequential_model\l::setup_layer_topology" alt="" coords="693,43,859,81"/>
<area shape="rect" id="node6" href="classlbann_1_1sequential__model.html#abf2b69dacb5ee3165289377e1d961cd5" title="lbann::sequential_model\l::name" alt="" coords="922,8,1088,47"/>
<area shape="rect" id="node8" href="classlbann_1_1greedy__layerwise__autoencoder.html#a115607e435ae4685531a81852ce01fe7" title="lbann::greedy_layerwise\l_autoencoder::setup_layer\l_topology" alt="" coords="915,71,1095,123"/>
<area shape="rect" id="node7" href="classlbann_1_1sequential__model.html#a53a83327a1115a53affa78c93344e641" title="lbann::sequential_model\l::write_proto" alt="" coords="1160,8,1325,47"/>
<area shape="rect" id="node11" href="classlbann_1_1directed__acyclic__graph__model.html#a2a70d5719832c481db9fa962f6e5f2bd" title="lbann::directed_acyclic\l_graph_model::setup_layer\l_execution_order" alt="" coords="1151,195,1334,247"/>
<area shape="rect" id="node12" href="classlbann_1_1directed__acyclic__graph__model.html#a9f2a6e9472235ec91c5a50356471b3cb" title="lbann::directed_acyclic\l_graph_model::freeze_layers\l_under_frozen_surface" alt="" coords="1382,160,1576,212"/>
<area shape="rect" id="node13" href="classlbann_1_1siamese__model.html#a7ff41cffb060500605124959f1a2a6cf" title="lbann::siamese_model\l::setup_layer_topology" alt="" coords="1401,236,1557,275"/>
<area shape="rect" id="node14" href="classlbann_1_1siamese__model.html#ad745961977aa395e11543d263103126e" title="lbann::siamese_model\l::name" alt="" coords="1624,236,1779,275"/>
</map>
</div>

</div>
</div>
<a id="a54de9f8e26046c834acfc5436a93b66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54de9f8e26046c834acfc5436a93b66b">&#9670;&nbsp;</a></span>induce_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::set&lt; int &gt; &gt; lbann::graph::induce_subgraph </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an induced subgraph. Removes edges to nodes outside the set of nodes and returns the new set of edges. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00145">145</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                                                                                  {</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;  std::map&lt;int,std::set&lt;int&gt;&gt; induced_edges;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : nodes) {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;      <span class="keywordflow">if</span> (nodes.count(neighbor) &gt; 0) {</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;        induced_edges[node].insert(neighbor);</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;      }</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    }</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  }</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;  <span class="keywordflow">return</span> induced_edges;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b_cgraph" id="namespacelbann_1_1graph_a54de9f8e26046c834acfc5436a93b66b_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="196,12,383,37"/>
</map>
</div>

</div>
</div>
<a id="ac9c1819b38f8bc514ab24ac8778f840b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9c1819b38f8bc514ab24ac8778f840b">&#9670;&nbsp;</a></span>is_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lbann::graph::is_closure </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a graph is a closure. A closure is a set of nodes with no edges to nodes outside the set. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00058">58</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                                                      {</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : nodes) {</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;      <span class="keywordflow">if</span> (nodes.count(neighbor) == 0) {</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;      }</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    }</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  }</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_cgraph" id="namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="216,5,404,31"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_icgraph.png" border="0" usemap="#namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_icgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_icgraph" id="namespacelbann_1_1graph_ac9c1819b38f8bc514ab24ac8778f840b_icgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328" title="lbann::graph::is_topologically\l_sorted" alt="" coords="216,69,410,108"/>
<area shape="rect" id="node7" href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb" title="lbann::graph::is_cyclic" alt="" coords="464,133,617,159"/>
<area shape="rect" id="node8" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee" title="lbann::graph::topological_sort" alt="" coords="671,148,868,173"/>
<area shape="rect" id="node14" href="namespacelbann_1_1graph.html#a53b0b97c3fc0b88f2fffd44f1b951c71" title="lbann::graph::transpose" alt="" coords="232,235,394,260"/>
<area shape="rect" id="node3" href="classlbann_1_1sequential__model.html#a3801a58530388fb6a8cb3e1c018e827d" title="lbann::sequential_model\l::setup_layer_topology" alt="" coords="458,19,623,57"/>
<area shape="rect" id="node4" href="classlbann_1_1sequential__model.html#abf2b69dacb5ee3165289377e1d961cd5" title="lbann::sequential_model\l::name" alt="" coords="687,5,852,44"/>
<area shape="rect" id="node6" href="classlbann_1_1greedy__layerwise__autoencoder.html#a115607e435ae4685531a81852ce01fe7" title="lbann::greedy_layerwise\l_autoencoder::setup_layer\l_topology" alt="" coords="680,68,859,120"/>
<area shape="rect" id="node5" href="classlbann_1_1sequential__model.html#a53a83327a1115a53affa78c93344e641" title="lbann::sequential_model\l::write_proto" alt="" coords="924,5,1090,44"/>
<area shape="rect" id="node9" href="classlbann_1_1directed__acyclic__graph__model.html#a2a70d5719832c481db9fa962f6e5f2bd" title="lbann::directed_acyclic\l_graph_model::setup_layer\l_execution_order" alt="" coords="916,135,1099,187"/>
<area shape="rect" id="node13" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca" title="lbann::graph::condensation" alt="" coords="916,217,1098,243"/>
<area shape="rect" id="node10" href="classlbann_1_1directed__acyclic__graph__model.html#a9f2a6e9472235ec91c5a50356471b3cb" title="lbann::directed_acyclic\l_graph_model::freeze_layers\l_under_frozen_surface" alt="" coords="1147,100,1341,152"/>
<area shape="rect" id="node11" href="classlbann_1_1siamese__model.html#a7ff41cffb060500605124959f1a2a6cf" title="lbann::siamese_model\l::setup_layer_topology" alt="" coords="1166,176,1321,215"/>
<area shape="rect" id="node12" href="classlbann_1_1siamese__model.html#ad745961977aa395e11543d263103126e" title="lbann::siamese_model\l::name" alt="" coords="1389,176,1543,215"/>
</map>
</div>

</div>
</div>
<a id="a7cb66f3455c79ca9c959bcf2c36a92eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb66f3455c79ca9c959bcf2c36a92eb">&#9670;&nbsp;</a></span>is_cyclic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lbann::graph::is_cyclic </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a directed graph is cyclic. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00086">86</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;                                                     {</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  <span class="comment">// Check that graph is valid</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">is_closure</a>(nodes, edges)) {</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;    std::stringstream err;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    err &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; :: &quot;</span> &lt;&lt; <span class="stringliteral">&quot;graph is not a closure&quot;</span>;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">throw</span> lbann_exception(err.str());</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;  }</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;  <span class="comment">// Topologically sorted graphs are not cyclic</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328">is_topologically_sorted</a>(nodes, edges)) {</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  }</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// Perform depth-first searches to detect cycles</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  std::unordered_map&lt;int,bool&gt; is_visited, is_sorted;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;  std::stack&lt;int&gt; search_stack;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp;&amp; it = nodes.rbegin(); it != nodes.rend(); ++it) {</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;    search_stack.push(*it);</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  }</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  <span class="keywordflow">while</span> (!search_stack.empty()) {</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; node = search_stack.top();</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    search_stack.pop();</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <span class="keywordflow">if</span> (!is_sorted[node]) {</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;      <span class="keywordflow">if</span> (is_visited[node]) {</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;        is_sorted[node] = <span class="keyword">true</span>;</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        is_visited[node] = <span class="keyword">true</span>;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        search_stack.push(node);</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;          <span class="keywordflow">if</span> (is_visited[neighbor] &amp;&amp; !is_sorted[neighbor]) {</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;          }</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;          search_stack.push(neighbor);</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        }</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      }</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;    }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;  }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;  </div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_a0dd9dcef8bc13481677692347530e328"><div class="ttname"><a href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328">lbann::graph::is_topologically_sorted</a></div><div class="ttdeci">bool is_topologically_sorted(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00070">graph.cpp:70</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_ac9c1819b38f8bc514ab24ac8778f840b"><div class="ttname"><a href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">lbann::graph::is_closure</a></div><div class="ttdeci">bool is_closure(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00058">graph.cpp:58</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_cgraph" id="namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b" title="lbann::graph::is_closure" alt="" coords="447,26,610,52"/>
<area shape="rect" id="node3" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="658,26,845,52"/>
<area shape="rect" id="node4" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328" title="lbann::graph::is_topologically\l_sorted" alt="" coords="206,76,399,114"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_icgraph.png" border="0" usemap="#namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_icgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_icgraph" id="namespacelbann_1_1graph_a7cb66f3455c79ca9c959bcf2c36a92eb_icgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee" title="lbann::graph::topological_sort" alt="" coords="206,85,402,111"/>
<area shape="rect" id="node3" href="classlbann_1_1directed__acyclic__graph__model.html#a2a70d5719832c481db9fa962f6e5f2bd" title="lbann::directed_acyclic\l_graph_model::setup_layer\l_execution_order" alt="" coords="450,40,633,92"/>
<area shape="rect" id="node7" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca" title="lbann::graph::condensation" alt="" coords="450,116,633,141"/>
<area shape="rect" id="node4" href="classlbann_1_1directed__acyclic__graph__model.html#a9f2a6e9472235ec91c5a50356471b3cb" title="lbann::directed_acyclic\l_graph_model::freeze_layers\l_under_frozen_surface" alt="" coords="681,5,875,57"/>
<area shape="rect" id="node5" href="classlbann_1_1siamese__model.html#a7ff41cffb060500605124959f1a2a6cf" title="lbann::siamese_model\l::setup_layer_topology" alt="" coords="700,81,856,120"/>
<area shape="rect" id="node6" href="classlbann_1_1siamese__model.html#ad745961977aa395e11543d263103126e" title="lbann::siamese_model\l::name" alt="" coords="923,81,1078,120"/>
</map>
</div>

</div>
</div>
<a id="a0dd9dcef8bc13481677692347530e328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd9dcef8bc13481677692347530e328">&#9670;&nbsp;</a></span>is_topologically_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lbann::graph::is_topologically_sorted </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether a graph is topologically sorted. A topologically sorted graph has no edges going from a node to an earlier node. The graph must be a directed acyclic graph. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00070">70</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                                                   {</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">is_closure</a>(nodes, edges)) {</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;    std::stringstream err;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;    err &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; :: &quot;</span> &lt;&lt; <span class="stringliteral">&quot;graph is not a closure&quot;</span>;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;    <span class="keywordflow">throw</span> lbann_exception(err.str());</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;  }</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : nodes) {</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbors = <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges);</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;    <span class="keywordflow">if</span> (neighbors.size() &gt; 0 &amp;&amp; *neighbors.begin() &lt;= node) {</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;    }</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  }</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_ac9c1819b38f8bc514ab24ac8778f840b"><div class="ttname"><a href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">lbann::graph::is_closure</a></div><div class="ttdeci">bool is_closure(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00058">graph.cpp:58</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_cgraph" id="namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b" title="lbann::graph::is_closure" alt="" coords="247,5,410,31"/>
<area shape="rect" id="node3" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="458,31,645,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_icgraph.png" border="0" usemap="#namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_icgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_icgraph" id="namespacelbann_1_1graph_a0dd9dcef8bc13481677692347530e328_icgraph">
<area shape="rect" id="node2" href="classlbann_1_1sequential__model.html#a3801a58530388fb6a8cb3e1c018e827d" title="lbann::sequential_model\l::setup_layer_topology" alt="" coords="247,63,413,101"/>
<area shape="rect" id="node6" href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb" title="lbann::graph::is_cyclic" alt="" coords="253,125,406,151"/>
<area shape="rect" id="node7" href="namespacelbann_1_1graph.html#aeb19a22d8fac402df104ed8d547a10ee" title="lbann::graph::topological_sort" alt="" coords="461,155,657,180"/>
<area shape="rect" id="node3" href="classlbann_1_1sequential__model.html#abf2b69dacb5ee3165289377e1d961cd5" title="lbann::sequential_model\l::name" alt="" coords="476,5,642,44"/>
<area shape="rect" id="node5" href="classlbann_1_1greedy__layerwise__autoencoder.html#a115607e435ae4685531a81852ce01fe7" title="lbann::greedy_layerwise\l_autoencoder::setup_layer\l_topology" alt="" coords="469,68,648,120"/>
<area shape="rect" id="node4" href="classlbann_1_1sequential__model.html#a53a83327a1115a53affa78c93344e641" title="lbann::sequential_model\l::write_proto" alt="" coords="713,5,879,44"/>
<area shape="rect" id="node8" href="classlbann_1_1directed__acyclic__graph__model.html#a2a70d5719832c481db9fa962f6e5f2bd" title="lbann::directed_acyclic\l_graph_model::setup_layer\l_execution_order" alt="" coords="705,99,888,151"/>
<area shape="rect" id="node12" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca" title="lbann::graph::condensation" alt="" coords="705,175,887,200"/>
<area shape="rect" id="node9" href="classlbann_1_1directed__acyclic__graph__model.html#a9f2a6e9472235ec91c5a50356471b3cb" title="lbann::directed_acyclic\l_graph_model::freeze_layers\l_under_frozen_surface" alt="" coords="936,64,1130,116"/>
<area shape="rect" id="node10" href="classlbann_1_1siamese__model.html#a7ff41cffb060500605124959f1a2a6cf" title="lbann::siamese_model\l::setup_layer_topology" alt="" coords="955,140,1110,179"/>
<area shape="rect" id="node11" href="classlbann_1_1siamese__model.html#ad745961977aa395e11543d263103126e" title="lbann::siamese_model\l::name" alt="" coords="1178,140,1332,179"/>
</map>
</div>

</div>
</div>
<a id="a956e9f6f1b842a2ffe5bda9015bbb906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956e9f6f1b842a2ffe5bda9015bbb906">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lbann::graph::print </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the nodes and edges of a graph to an output stream. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00037">37</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;                           {</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : nodes) {</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; neighbors :&quot;</span>;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      os &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; neighbor;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    }</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    os &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  }</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906_cgraph" id="namespacelbann_1_1graph_a956e9f6f1b842a2ffe5bda9015bbb906_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="182,5,370,31"/>
</map>
</div>

</div>
</div>
<a id="aeb19a22d8fac402df104ed8d547a10ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb19a22d8fac402df104ed8d547a10ee">&#9670;&nbsp;</a></span>topological_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; lbann::graph::topological_sort </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Topologically sort a graph. A topologically sorted graph has no edges going from a node to an earlier node. The sort is deterministic and does not affect graphs that are already topologically sorted. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00222">222</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                                                                        {</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <span class="comment">// Check that graph is valid</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">is_closure</a>(nodes, edges)) {</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    std::stringstream err;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    err &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; :: &quot;</span> &lt;&lt; <span class="stringliteral">&quot;graph is not a closure&quot;</span>;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keywordflow">throw</span> lbann_exception(err.str());</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  }</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb">is_cyclic</a>(nodes, edges)) {</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    std::stringstream err;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    err &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; :: &quot;</span> &lt;&lt; <span class="stringliteral">&quot;graph is cyclic&quot;</span>;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;    <span class="keywordflow">throw</span> lbann_exception(err.str());</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;  }</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;  <span class="comment">// Return original order if already sorted</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328">is_topologically_sorted</a>(nodes, edges)) {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">return</span> std::vector&lt;int&gt;(nodes.begin(), nodes.end());</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;  }</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;  <span class="comment">// Perform depth-first searches on nodes</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  std::stack&lt;int&gt; sorted_stack;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;  std::unordered_map&lt;int,bool&gt; is_sorted;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; root : nodes) {</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">if</span> (!is_sorted[root]) {</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      <span class="keyword">const</span> <span class="keyword">auto</span>&amp; dfs = <a class="code" href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974">depth_first_search</a>(root, edges);</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : dfs) {</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">if</span> (!is_sorted[node]) {</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;          is_sorted[node] = <span class="keyword">true</span>;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;          sorted_stack.push(node);</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        }</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;      }</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    }</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  }</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  <span class="comment">// Reverse DFS post-order is topologically sorted</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  std::vector&lt;int&gt; sorted_nodes;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <span class="keywordflow">while</span> (!sorted_stack.empty()) {</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    sorted_nodes.push_back(sorted_stack.top());</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    sorted_stack.pop();</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;  }</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <span class="keywordflow">return</span> sorted_nodes;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  </div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_a0dd9dcef8bc13481677692347530e328"><div class="ttname"><a href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328">lbann::graph::is_topologically_sorted</a></div><div class="ttdeci">bool is_topologically_sorted(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00070">graph.cpp:70</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_a7cb66f3455c79ca9c959bcf2c36a92eb"><div class="ttname"><a href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb">lbann::graph::is_cyclic</a></div><div class="ttdeci">bool is_cyclic(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00086">graph.cpp:86</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_a44394207f3566604f867382b10aaf974"><div class="ttname"><a href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974">lbann::graph::depth_first_search</a></div><div class="ttdeci">std::vector&lt; int &gt; depth_first_search(int root, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00185">graph.cpp:185</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_ac9c1819b38f8bc514ab24ac8778f840b"><div class="ttname"><a href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">lbann::graph::is_closure</a></div><div class="ttdeci">bool is_closure(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00058">graph.cpp:58</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_cgraph" id="namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b" title="lbann::graph::is_closure" alt="" coords="691,32,854,57"/>
<area shape="rect" id="node4" href="namespacelbann_1_1graph.html#a7cb66f3455c79ca9c959bcf2c36a92eb" title="lbann::graph::is_cyclic" alt="" coords="250,32,402,57"/>
<area shape="rect" id="node5" href="namespacelbann_1_1graph.html#a0dd9dcef8bc13481677692347530e328" title="lbann::graph::is_topologically\l_sorted" alt="" coords="450,80,643,118"/>
<area shape="rect" id="node6" href="namespacelbann_1_1graph.html#a44394207f3566604f867382b10aaf974" title="lbann::graph::depth\l_first_search" alt="" coords="479,142,615,181"/>
<area shape="rect" id="node3" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="902,57,1090,82"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_icgraph.png" border="0" usemap="#namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_icgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_icgraph" id="namespacelbann_1_1graph_aeb19a22d8fac402df104ed8d547a10ee_icgraph">
<area shape="rect" id="node2" href="classlbann_1_1directed__acyclic__graph__model.html#a2a70d5719832c481db9fa962f6e5f2bd" title="lbann::directed_acyclic\l_graph_model::setup_layer\l_execution_order" alt="" coords="250,40,433,92"/>
<area shape="rect" id="node6" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca" title="lbann::graph::condensation" alt="" coords="250,116,432,141"/>
<area shape="rect" id="node3" href="classlbann_1_1directed__acyclic__graph__model.html#a9f2a6e9472235ec91c5a50356471b3cb" title="lbann::directed_acyclic\l_graph_model::freeze_layers\l_under_frozen_surface" alt="" coords="481,5,675,57"/>
<area shape="rect" id="node4" href="classlbann_1_1siamese__model.html#a7ff41cffb060500605124959f1a2a6cf" title="lbann::siamese_model\l::setup_layer_topology" alt="" coords="500,81,655,120"/>
<area shape="rect" id="node5" href="classlbann_1_1siamese__model.html#ad745961977aa395e11543d263103126e" title="lbann::siamese_model\l::name" alt="" coords="723,81,877,120"/>
</map>
</div>

</div>
</div>
<a id="a53b0b97c3fc0b88f2fffd44f1b951c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b0b97c3fc0b88f2fffd44f1b951c71">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; int, std::set&lt; int &gt; &gt; lbann::graph::transpose </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the transpose of a graph. Reverses the direction of edges in the graph and returns the new set of edges. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cpp_source.html#l00129">129</a> of file <a class="el" href="graph_8cpp_source.html">graph.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;                                                                            {</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">is_closure</a>(nodes, edges)) {</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    std::stringstream err;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;    err &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot; :: &quot;</span> &lt;&lt; <span class="stringliteral">&quot;graph is not a closure&quot;</span>;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;    <span class="keywordflow">throw</span> lbann_exception(err.str());</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  }</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  std::map&lt;int,std::set&lt;int&gt;&gt; transpose_edges;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; node : nodes) {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; neighbor : <a class="code" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">get_neighbors</a>(node, edges)) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      transpose_edges[neighbor].insert(node);</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    }</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  }</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keywordflow">return</span> transpose_edges;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div><div class="ttc" id="namespacelbann_1_1graph_html_ad305e0d104d25d9cb1e63a4b93c0847c"><div class="ttname"><a href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c">lbann::graph::get_neighbors</a></div><div class="ttdeci">std::set&lt; int &gt; get_neighbors(int node, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00049">graph.cpp:49</a></div></div>
<div class="ttc" id="namespacelbann_1_1graph_html_ac9c1819b38f8bc514ab24ac8778f840b"><div class="ttname"><a href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b">lbann::graph::is_closure</a></div><div class="ttdeci">bool is_closure(const std::set&lt; int &gt; &amp;nodes, const std::map&lt; int, std::set&lt; int &gt;&gt; &amp;edges)</div><div class="ttdef"><b>Definition:</b> <a href="graph_8cpp_source.html#l00058">graph.cpp:58</a></div></div>
</div><!-- fragment --><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_cgraph.png" border="0" usemap="#namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_cgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_cgraph" id="namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_cgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ac9c1819b38f8bc514ab24ac8778f840b" title="lbann::graph::is_closure" alt="" coords="215,5,378,31"/>
<area shape="rect" id="node3" href="namespacelbann_1_1graph.html#ad305e0d104d25d9cb1e63a4b93c0847c" title="lbann::graph::get_neighbors" alt="" coords="426,31,613,56"/>
</map>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_icgraph.png" border="0" usemap="#namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_icgraph" alt=""/></div>
<map name="namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_icgraph" id="namespacelbann_1_1graph_a53b0b97c3fc0b88f2fffd44f1b951c71_icgraph">
<area shape="rect" id="node2" href="namespacelbann_1_1graph.html#ae06c3de1931d3786348995d870b792ca" title="lbann::graph::condensation" alt="" coords="215,5,397,31"/>
</map>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacelbann.html">lbann</a></li><li class="navelem"><a class="el" href="namespacelbann_1_1graph.html">graph</a></li>
    <li class="footer">Generated on Tue Apr 24 2018 15:13:46 for LBANN by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
